{{/*
üóÑÔ∏è Database Optimization Configuration for SnapFix Enterprise

This template creates optimized database configurations for:
- PostgreSQL with advanced indexing and connection pooling
- MongoDB with optimized queries and connection management
- PgBouncer for PostgreSQL connection pooling
- Database monitoring and performance tuning
- Automated backup and maintenance jobs
*/}}

{{- if .Values.database.optimization.enabled }}
{{/*
üìä Database Optimization ConfigMap
*/}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "snapfix-enterprise.fullname" . }}-db-optimization-config
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "snapfix-enterprise.labels" . | nindent 4 }}
    app.kubernetes.io/component: db-optimization
    app.kubernetes.io/part-of: snapfix-enterprise
data:
  # PostgreSQL Optimization Configuration
  postgresql-optimization.conf: |
    # ========================================
    # POSTGRESQL PERFORMANCE OPTIMIZATION
    # ========================================
    
    # Memory Settings
    shared_buffers = {{ .Values.database.postgresql.optimization.sharedBuffers | default "256MB" }}
    effective_cache_size = {{ .Values.database.postgresql.optimization.effectiveCacheSize | default "1GB" }}
    maintenance_work_mem = {{ .Values.database.postgresql.optimization.maintenanceWorkMem | default "64MB" }}
    work_mem = {{ .Values.database.postgresql.optimization.workMem | default "4MB" }}
    
    # Checkpoint Settings
    checkpoint_completion_target = {{ .Values.database.postgresql.optimization.checkpointCompletionTarget | default 0.9 }}
    wal_buffers = {{ .Values.database.postgresql.optimization.walBuffers | default "16MB" }}
    
    # Connection Settings
    max_connections = {{ .Values.database.postgresql.optimization.maxConnections | default 200 }}
    
    # Query Planner Settings
    random_page_cost = {{ .Values.database.postgresql.optimization.randomPageCost | default 1.1 }}
    effective_io_concurrency = {{ .Values.database.postgresql.optimization.effectiveIoConcurrency | default 200 }}
    
    # Logging Settings for Performance Monitoring
    log_min_duration_statement = {{ .Values.database.postgresql.optimization.logMinDurationStatement | default 1000 }}
    log_checkpoints = on
    log_connections = on
    log_disconnections = on
    log_lock_waits = on
    log_temp_files = 0
    
    # Auto Vacuum Settings
    autovacuum = on
    autovacuum_max_workers = {{ .Values.database.postgresql.optimization.autovacuumMaxWorkers | default 3 }}
    autovacuum_naptime = {{ .Values.database.postgresql.optimization.autovacuumNaptime | default "1min" }}
    
    # Statistics Settings
    track_activities = on
    track_counts = on
    track_io_timing = on
    track_functions = all
    
  # PgBouncer Configuration
  pgbouncer.ini: |
    [databases]
    {{ .Values.database.postgresql.database | default "snapfix" }} = host={{ include "snapfix-enterprise.fullname" . }}-postgresql port=5432 dbname={{ .Values.database.postgresql.database | default "snapfix" }}
    
    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    auth_type = {{ .Values.database.pgbouncer.authType | default "md5" }}
    auth_file = /etc/pgbouncer/userlist.txt
    
    # Pool settings
    pool_mode = {{ .Values.database.pgbouncer.poolMode | default "transaction" }}
    max_client_conn = {{ .Values.database.pgbouncer.maxClientConn | default 1000 }}
    default_pool_size = {{ .Values.database.pgbouncer.defaultPoolSize | default 25 }}
    min_pool_size = {{ .Values.database.pgbouncer.minPoolSize | default 5 }}
    reserve_pool_size = {{ .Values.database.pgbouncer.reservePoolSize | default 5 }}
    reserve_pool_timeout = {{ .Values.database.pgbouncer.reservePoolTimeout | default 3 }}
    
    # Connection limits
    max_db_connections = {{ .Values.database.pgbouncer.maxDbConnections | default 50 }}
    max_user_connections = {{ .Values.database.pgbouncer.maxUserConnections | default 50 }}
    
    # Timeouts
    server_reset_query = DISCARD ALL
    server_check_delay = {{ .Values.database.pgbouncer.serverCheckDelay | default 30 }}
    server_check_query = select 1
    server_lifetime = {{ .Values.database.pgbouncer.serverLifetime | default 3600 }}
    server_idle_timeout = {{ .Values.database.pgbouncer.serverIdleTimeout | default 600 }}
    
    # Logging
    admin_users = {{ .Values.database.pgbouncer.adminUsers | default "postgres" }}
    stats_users = {{ .Values.database.pgbouncer.statsUsers | default "postgres" }}
    log_connections = {{ .Values.database.pgbouncer.logConnections | default 1 }}
    log_disconnections = {{ .Values.database.pgbouncer.logDisconnections | default 1 }}
    log_pooler_errors = {{ .Values.database.pgbouncer.logPoolerErrors | default 1 }}
    
  # Database Indexing Scripts
  create-indexes.sql: |
    -- ========================================
    -- SNAPFIX ENTERPRISE DATABASE INDEXES
    -- ========================================
    
    -- Users table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_username ON users(username);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_created_at ON users(created_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_last_login ON users(last_login_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_status ON users(status) WHERE status IN ('active', 'inactive');
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_role ON users(role);
    
    -- Tickets table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_user_id ON tickets(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_status ON tickets(status);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_priority ON tickets(priority);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_created_at ON tickets(created_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_updated_at ON tickets(updated_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_assigned_to ON tickets(assigned_to);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_category ON tickets(category);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_search ON tickets USING gin(to_tsvector('english', title || ' ' || description));
    
    -- Composite indexes for common queries
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_user_status ON tickets(user_id, status);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_status_priority ON tickets(status, priority);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_assigned_status ON tickets(assigned_to, status);
    
    -- Comments table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_comments_ticket_id ON comments(ticket_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_comments_user_id ON comments(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_comments_created_at ON comments(created_at);
    
    -- Attachments table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_attachments_ticket_id ON attachments(ticket_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_attachments_user_id ON attachments(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_attachments_file_type ON attachments(file_type);
    
    -- Audit logs table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_audit_logs_resource_type ON audit_logs(resource_type);
    
    -- Sessions table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_sessions_user_id ON sessions(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_sessions_expires_at ON sessions(expires_at);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_sessions_token ON sessions(token);
    
    -- Notifications table indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_read ON notifications(is_read);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_notifications_created_at ON notifications(created_at);
    
    -- Analytics and reporting indexes
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_analytics ON tickets(created_at, status, priority, category);
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_analytics ON users(created_at, role, status);
    
    -- Partial indexes for better performance
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_open ON tickets(created_at) WHERE status IN ('open', 'in_progress');
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_tickets_unassigned ON tickets(created_at) WHERE assigned_to IS NULL;
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_active ON users(last_login_at) WHERE status = 'active';
    
    -- Update table statistics
    ANALYZE users;
    ANALYZE tickets;
    ANALYZE comments;
    ANALYZE attachments;
    ANALYZE audit_logs;
    ANALYZE sessions;
    ANALYZE notifications;
    
  # Query optimization scripts
  optimize-queries.sql: |
    -- ========================================
    -- QUERY OPTIMIZATION PROCEDURES
    -- ========================================
    
    -- Function to get user tickets with pagination
    CREATE OR REPLACE FUNCTION get_user_tickets(
        p_user_id INTEGER,
        p_status TEXT DEFAULT NULL,
        p_limit INTEGER DEFAULT 20,
        p_offset INTEGER DEFAULT 0
    )
    RETURNS TABLE(
        ticket_id INTEGER,
        title TEXT,
        status TEXT,
        priority TEXT,
        created_at TIMESTAMP,
        updated_at TIMESTAMP
    ) AS $$
    BEGIN
        RETURN QUERY
        SELECT t.id, t.title, t.status, t.priority, t.created_at, t.updated_at
        FROM tickets t
        WHERE t.user_id = p_user_id
        AND (p_status IS NULL OR t.status = p_status)
        ORDER BY t.updated_at DESC
        LIMIT p_limit OFFSET p_offset;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Function for ticket search with full-text search
    CREATE OR REPLACE FUNCTION search_tickets(
        p_search_term TEXT,
        p_user_id INTEGER DEFAULT NULL,
        p_limit INTEGER DEFAULT 20,
        p_offset INTEGER DEFAULT 0
    )
    RETURNS TABLE(
        ticket_id INTEGER,
        title TEXT,
        description TEXT,
        status TEXT,
        priority TEXT,
        rank REAL
    ) AS $$
    BEGIN
        RETURN QUERY
        SELECT 
            t.id,
            t.title,
            t.description,
            t.status,
            t.priority,
            ts_rank(to_tsvector('english', t.title || ' ' || t.description), plainto_tsquery('english', p_search_term)) as rank
        FROM tickets t
        WHERE to_tsvector('english', t.title || ' ' || t.description) @@ plainto_tsquery('english', p_search_term)
        AND (p_user_id IS NULL OR t.user_id = p_user_id)
        ORDER BY rank DESC, t.updated_at DESC
        LIMIT p_limit OFFSET p_offset;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Materialized view for dashboard analytics
    CREATE MATERIALIZED VIEW IF NOT EXISTS dashboard_stats AS
    SELECT 
        COUNT(*) as total_tickets,
        COUNT(*) FILTER (WHERE status = 'open') as open_tickets,
        COUNT(*) FILTER (WHERE status = 'in_progress') as in_progress_tickets,
        COUNT(*) FILTER (WHERE status = 'resolved') as resolved_tickets,
        COUNT(*) FILTER (WHERE status = 'closed') as closed_tickets,
        COUNT(*) FILTER (WHERE priority = 'high') as high_priority_tickets,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as tickets_last_week,
        COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as tickets_last_month,
        AVG(EXTRACT(EPOCH FROM (updated_at - created_at))/3600) FILTER (WHERE status = 'resolved') as avg_resolution_time_hours
    FROM tickets;
    
    -- Create index on materialized view
    CREATE UNIQUE INDEX IF NOT EXISTS idx_dashboard_stats ON dashboard_stats ((1));
    
    -- Function to refresh dashboard stats
    CREATE OR REPLACE FUNCTION refresh_dashboard_stats()
    RETURNS VOID AS $$
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY dashboard_stats;
    END;
    $$ LANGUAGE plpgsql;
    
  # MongoDB Optimization Scripts
  mongodb-indexes.js: |
    // ========================================
    // MONGODB INDEXES FOR SNAPFIX ENTERPRISE
    // ========================================
    
    // Switch to snapfix database
    use('{{ .Values.database.mongodb.database | default "snapfix" }}');
    
    // Users collection indexes
    db.users.createIndex({ "email": 1 }, { unique: true, background: true });
    db.users.createIndex({ "username": 1 }, { unique: true, background: true });
    db.users.createIndex({ "createdAt": 1 }, { background: true });
    db.users.createIndex({ "lastLoginAt": 1 }, { background: true });
    db.users.createIndex({ "status": 1 }, { background: true });
    db.users.createIndex({ "role": 1 }, { background: true });
    
    // Tickets collection indexes
    db.tickets.createIndex({ "userId": 1 }, { background: true });
    db.tickets.createIndex({ "status": 1 }, { background: true });
    db.tickets.createIndex({ "priority": 1 }, { background: true });
    db.tickets.createIndex({ "createdAt": 1 }, { background: true });
    db.tickets.createIndex({ "updatedAt": 1 }, { background: true });
    db.tickets.createIndex({ "assignedTo": 1 }, { background: true });
    db.tickets.createIndex({ "category": 1 }, { background: true });
    
    // Text search index for tickets
    db.tickets.createIndex(
        { "title": "text", "description": "text", "tags": "text" },
        { background: true, weights: { "title": 10, "description": 5, "tags": 1 } }
    );
    
    // Compound indexes for common queries
    db.tickets.createIndex({ "userId": 1, "status": 1 }, { background: true });
    db.tickets.createIndex({ "status": 1, "priority": 1 }, { background: true });
    db.tickets.createIndex({ "assignedTo": 1, "status": 1 }, { background: true });
    db.tickets.createIndex({ "createdAt": 1, "status": 1 }, { background: true });
    
    // Comments collection indexes
    db.comments.createIndex({ "ticketId": 1 }, { background: true });
    db.comments.createIndex({ "userId": 1 }, { background: true });
    db.comments.createIndex({ "createdAt": 1 }, { background: true });
    db.comments.createIndex({ "ticketId": 1, "createdAt": 1 }, { background: true });
    
    // Attachments collection indexes
    db.attachments.createIndex({ "ticketId": 1 }, { background: true });
    db.attachments.createIndex({ "userId": 1 }, { background: true });
    db.attachments.createIndex({ "fileType": 1 }, { background: true });
    db.attachments.createIndex({ "uploadedAt": 1 }, { background: true });
    
    // Analytics collection indexes
    db.analytics.createIndex({ "eventType": 1 }, { background: true });
    db.analytics.createIndex({ "userId": 1 }, { background: true });
    db.analytics.createIndex({ "timestamp": 1 }, { background: true });
    db.analytics.createIndex({ "eventType": 1, "timestamp": 1 }, { background: true });
    
    // Sessions collection indexes
    db.sessions.createIndex({ "userId": 1 }, { background: true });
    db.sessions.createIndex({ "token": 1 }, { unique: true, background: true });
    db.sessions.createIndex({ "expiresAt": 1 }, { expireAfterSeconds: 0, background: true });
    
    // Notifications collection indexes
    db.notifications.createIndex({ "userId": 1 }, { background: true });
    db.notifications.createIndex({ "isRead": 1 }, { background: true });
    db.notifications.createIndex({ "createdAt": 1 }, { background: true });
    db.notifications.createIndex({ "userId": 1, "isRead": 1 }, { background: true });
    
    // Audit logs collection indexes
    db.auditLogs.createIndex({ "userId": 1 }, { background: true });
    db.auditLogs.createIndex({ "action": 1 }, { background: true });
    db.auditLogs.createIndex({ "resourceType": 1 }, { background: true });
    db.auditLogs.createIndex({ "timestamp": 1 }, { background: true });
    
    // Partial indexes for better performance
    db.tickets.createIndex(
        { "createdAt": 1 },
        { partialFilterExpression: { "status": { $in: ["open", "in_progress"] } }, background: true }
    );
    
    db.users.createIndex(
        { "lastLoginAt": 1 },
        { partialFilterExpression: { "status": "active" }, background: true }
    );
    
    print("MongoDB indexes created successfully");
    
  # Database maintenance scripts
  maintenance.sql: |
    -- ========================================
    -- DATABASE MAINTENANCE PROCEDURES
    -- ========================================
    
    -- Procedure to clean up old sessions
    CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
    RETURNS INTEGER AS $$
    DECLARE
        deleted_count INTEGER;
    BEGIN
        DELETE FROM sessions WHERE expires_at < NOW();
        GET DIAGNOSTICS deleted_count = ROW_COUNT;
        RETURN deleted_count;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Procedure to archive old audit logs
    CREATE OR REPLACE FUNCTION archive_old_audit_logs(days_to_keep INTEGER DEFAULT 90)
    RETURNS INTEGER AS $$
    DECLARE
        archived_count INTEGER;
    BEGIN
        -- Move old logs to archive table
        INSERT INTO audit_logs_archive 
        SELECT * FROM audit_logs 
        WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep;
        
        -- Delete from main table
        DELETE FROM audit_logs 
        WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep;
        
        GET DIAGNOSTICS archived_count = ROW_COUNT;
        RETURN archived_count;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Procedure to update table statistics
    CREATE OR REPLACE FUNCTION update_table_statistics()
    RETURNS VOID AS $$
    BEGIN
        ANALYZE users;
        ANALYZE tickets;
        ANALYZE comments;
        ANALYZE attachments;
        ANALYZE audit_logs;
        ANALYZE sessions;
        ANALYZE notifications;
    END;
    $$ LANGUAGE plpgsql;
    
    -- Procedure to reindex tables
    CREATE OR REPLACE FUNCTION reindex_tables()
    RETURNS VOID AS $$
    BEGIN
        REINDEX TABLE users;
        REINDEX TABLE tickets;
        REINDEX TABLE comments;
        REINDEX TABLE attachments;
        REINDEX TABLE audit_logs;
        REINDEX TABLE sessions;
        REINDEX TABLE notifications;
    END;
    $$ LANGUAGE plpgsql;

---
{{/*
üîÑ PgBouncer Connection Pooler Deployment
*/}}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "snapfix-enterprise.fullname" . }}-pgbouncer
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "snapfix-enterprise.labels" . | nindent 4 }}
    app.kubernetes.io/component: pgbouncer
    app.kubernetes.io/part-of: snapfix-enterprise
spec:
  replicas: {{ .Values.database.pgbouncer.replicas | default 2 }}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      {{- include "snapfix-enterprise.selectorLabels" . | nindent 6 }}
      app.kubernetes.io/component: pgbouncer
  template:
    metadata:
      labels:
        {{- include "snapfix-enterprise.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: pgbouncer
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/database-optimization.yaml") . | sha256sum }}
        {{- if .Values.monitoring.prometheus.enabled }}
        prometheus.io/scrape: "true"
        prometheus.io/port: "9127"
        prometheus.io/path: "/metrics"
        {{- end }}
    spec:
      {{- with .Values.database.pgbouncer.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    {{- include "snapfix-enterprise.selectorLabels" . | nindent 20 }}
                    app.kubernetes.io/component: pgbouncer
                topologyKey: kubernetes.io/hostname
      
      containers:
        - name: pgbouncer
          image: "{{ .Values.database.pgbouncer.image.repository }}:{{ .Values.database.pgbouncer.image.tag | default "1.21.0" }}"
          imagePullPolicy: {{ .Values.database.pgbouncer.image.pullPolicy | default "IfNotPresent" }}
          
          ports:
            - name: pgbouncer
              containerPort: 6432
              protocol: TCP
          
          env:
            - name: DATABASES_HOST
              value: {{ include "snapfix-enterprise.fullname" . }}-postgresql
            - name: DATABASES_PORT
              value: "5432"
            - name: DATABASES_USER
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-username
            - name: DATABASES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-password
            - name: DATABASES_DBNAME
              value: {{ .Values.database.postgresql.database | default "snapfix" }}
          
          volumeMounts:
            - name: pgbouncer-config
              mountPath: /etc/pgbouncer
              readOnly: true
          
          livenessProbe:
            tcpSocket:
              port: pgbouncer
            initialDelaySeconds: 30
            periodSeconds: 30
            timeoutSeconds: 5
            failureThreshold: 3
          
          readinessProbe:
            tcpSocket:
              port: pgbouncer
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 3
          
          resources:
            {{- toYaml .Values.database.pgbouncer.resources | nindent 12 }}
        
        {{- if .Values.monitoring.prometheus.enabled }}
        - name: pgbouncer-exporter
          image: "{{ .Values.monitoring.pgbouncerExporter.image.repository }}:{{ .Values.monitoring.pgbouncerExporter.image.tag | default "v0.7.0" }}"
          imagePullPolicy: {{ .Values.monitoring.pgbouncerExporter.image.pullPolicy | default "IfNotPresent" }}
          
          ports:
            - name: metrics
              containerPort: 9127
              protocol: TCP
          
          env:
            - name: PGBOUNCER_EXPORTER_HOST
              value: "localhost"
            - name: PGBOUNCER_EXPORTER_PORT
              value: "6432"
            - name: PGBOUNCER_EXPORTER_USER
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-username
            - name: PGBOUNCER_EXPORTER_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-password
          
          livenessProbe:
            httpGet:
              path: /metrics
              port: metrics
            initialDelaySeconds: 30
            periodSeconds: 30
          
          readinessProbe:
            httpGet:
              path: /metrics
              port: metrics
            initialDelaySeconds: 10
            periodSeconds: 10
          
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 100m
              memory: 128Mi
        {{- end }}
      
      volumes:
        - name: pgbouncer-config
          configMap:
            name: {{ include "snapfix-enterprise.fullname" . }}-db-optimization-config

---
{{/*
üîÑ PgBouncer Service
*/}}
apiVersion: v1
kind: Service
metadata:
  name: {{ include "snapfix-enterprise.fullname" . }}-pgbouncer
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "snapfix-enterprise.labels" . | nindent 4 }}
    app.kubernetes.io/component: pgbouncer
    app.kubernetes.io/part-of: snapfix-enterprise
  annotations:
    {{- if .Values.monitoring.prometheus.enabled }}
    prometheus.io/scrape: "true"
    prometheus.io/port: "9127"
    prometheus.io/path: "/metrics"
    {{- end }}
spec:
  type: {{ .Values.database.pgbouncer.service.type | default "ClusterIP" }}
  ports:
    - name: pgbouncer
      port: 6432
      targetPort: pgbouncer
      protocol: TCP
    {{- if .Values.monitoring.prometheus.enabled }}
    - name: metrics
      port: 9127
      targetPort: metrics
      protocol: TCP
    {{- end }}
  selector:
    {{- include "snapfix-enterprise.selectorLabels" . | nindent 4 }}
    app.kubernetes.io/component: pgbouncer

---
{{/*
üîß Database Optimization Job
*/}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "snapfix-enterprise.fullname" . }}-db-optimization
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "snapfix-enterprise.labels" . | nindent 4 }}
    app.kubernetes.io/component: db-optimization
    app.kubernetes.io/part-of: snapfix-enterprise
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "15"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        {{- include "snapfix-enterprise.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: db-optimization
    spec:
      restartPolicy: Never
      
      initContainers:
        # PostgreSQL optimization
        - name: postgresql-optimization
          image: "{{ .Values.database.postgresql.image.repository }}:{{ .Values.database.postgresql.image.tag | default "15" }}"
          imagePullPolicy: {{ .Values.database.postgresql.image.pullPolicy | default "IfNotPresent" }}
          
          env:
            - name: PGHOST
              value: {{ include "snapfix-enterprise.fullname" . }}-postgresql
            - name: PGPORT
              value: "5432"
            - name: PGUSER
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-username
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                  key: postgres-password
            - name: PGDATABASE
              value: {{ .Values.database.postgresql.database | default "snapfix" }}
          
          command:
            - /bin/bash
            - -c
            - |
              echo "Creating PostgreSQL indexes and optimizations..."
              
              # Wait for PostgreSQL to be ready
              until pg_isready -h $PGHOST -p $PGPORT -U $PGUSER; do
                echo "Waiting for PostgreSQL to be ready..."
                sleep 5
              done
              
              # Apply indexes
              psql -f /scripts/create-indexes.sql
              
              # Apply query optimizations
              psql -f /scripts/optimize-queries.sql
              
              # Apply maintenance procedures
              psql -f /scripts/maintenance.sql
              
              echo "PostgreSQL optimization completed"
          
          volumeMounts:
            - name: optimization-scripts
              mountPath: /scripts
          
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 512Mi
        
        # MongoDB optimization
        - name: mongodb-optimization
          image: "{{ .Values.database.mongodb.image.repository }}:{{ .Values.database.mongodb.image.tag | default "7.0" }}"
          imagePullPolicy: {{ .Values.database.mongodb.image.pullPolicy | default "IfNotPresent" }}
          
          env:
            - name: MONGODB_HOST
              value: {{ include "snapfix-enterprise.fullname" . }}-mongodb-mongos
            - name: MONGODB_PORT
              value: "27017"
            - name: MONGODB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-mongodb-secret
                  key: mongodb-username
            - name: MONGODB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "snapfix-enterprise.fullname" . }}-mongodb-secret
                  key: mongodb-password
            - name: MONGODB_DATABASE
              value: {{ .Values.database.mongodb.database | default "snapfix" }}
          
          command:
            - /bin/bash
            - -c
            - |
              echo "Creating MongoDB indexes and optimizations..."
              
              # Wait for MongoDB to be ready
              until mongosh --host $MONGODB_HOST:$MONGODB_PORT --username $MONGODB_USERNAME --password $MONGODB_PASSWORD --authenticationDatabase admin --eval "db.adminCommand('ping')" > /dev/null 2>&1; do
                echo "Waiting for MongoDB to be ready..."
                sleep 5
              done
              
              # Apply MongoDB indexes
              mongosh --host $MONGODB_HOST:$MONGODB_PORT --username $MONGODB_USERNAME --password $MONGODB_PASSWORD --authenticationDatabase admin /scripts/mongodb-indexes.js
              
              echo "MongoDB optimization completed"
          
          volumeMounts:
            - name: optimization-scripts
              mountPath: /scripts
          
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 512Mi
      
      containers:
        - name: optimization-complete
          image: busybox:1.35
          command:
            - /bin/sh
            - -c
            - |
              echo "Database optimization completed successfully"
              echo "PostgreSQL indexes and query optimizations applied"
              echo "MongoDB indexes and optimizations applied"
              echo "PgBouncer connection pooling configured"
          
          resources:
            requests:
              cpu: 50m
              memory: 32Mi
            limits:
              cpu: 100m
              memory: 64Mi
      
      volumes:
        - name: optimization-scripts
          configMap:
            name: {{ include "snapfix-enterprise.fullname" . }}-db-optimization-config

---
{{/*
üîÑ Database Maintenance CronJob
*/}}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "snapfix-enterprise.fullname" . }}-db-maintenance
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "snapfix-enterprise.labels" . | nindent 4 }}
    app.kubernetes.io/component: db-maintenance
    app.kubernetes.io/part-of: snapfix-enterprise
spec:
  schedule: {{ .Values.database.maintenance.schedule | default "0 2 * * 0" }}  # Weekly at 2 AM Sunday
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            {{- include "snapfix-enterprise.selectorLabels" . | nindent 12 }}
            app.kubernetes.io/component: db-maintenance
        spec:
          restartPolicy: OnFailure
          
          containers:
            - name: db-maintenance
              image: "{{ .Values.database.postgresql.image.repository }}:{{ .Values.database.postgresql.image.tag | default "15" }}"
              imagePullPolicy: {{ .Values.database.postgresql.image.pullPolicy | default "IfNotPresent" }}
              
              env:
                - name: PGHOST
                  value: {{ include "snapfix-enterprise.fullname" . }}-postgresql
                - name: PGPORT
                  value: "5432"
                - name: PGUSER
                  valueFrom:
                    secretKeyRef:
                      name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                      key: postgres-username
                - name: PGPASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: {{ include "snapfix-enterprise.fullname" . }}-postgresql-secret
                      key: postgres-password
                - name: PGDATABASE
                  value: {{ .Values.database.postgresql.database | default "snapfix" }}
              
              command:
                - /bin/bash
                - -c
                - |
                  echo "Starting database maintenance..."
                  
                  # Clean up expired sessions
                  echo "Cleaning up expired sessions..."
                  psql -c "SELECT cleanup_expired_sessions();"
                  
                  # Archive old audit logs
                  echo "Archiving old audit logs..."
                  psql -c "SELECT archive_old_audit_logs(90);"
                  
                  # Update table statistics
                  echo "Updating table statistics..."
                  psql -c "SELECT update_table_statistics();"
                  
                  # Refresh materialized views
                  echo "Refreshing dashboard statistics..."
                  psql -c "SELECT refresh_dashboard_stats();"
                  
                  # Vacuum and analyze
                  echo "Running VACUUM ANALYZE..."
                  psql -c "VACUUM ANALYZE;"
                  
                  echo "Database maintenance completed successfully"
              
              resources:
                requests:
                  cpu: 200m
                  memory: 256Mi
                limits:
                  cpu: 1000m
                  memory: 1Gi

{{- end }}